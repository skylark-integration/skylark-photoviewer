{"version":3,"sources":["movable.js"],"names":["define","eventer","_movable","$","Constants","NS","movable","stage","image","starting","e","hasClass","imageWidth","width","imageHeight","height","stageWidth","stageHeight","minX","minY","maxX","maxY","constraints","started","stop"],"mappings":";;;;;;;AAAAA,QACI,uBACA,wCACA,SACA,eACD,SAAUC,EAAQC,EAASC,EAAGC,GAC7B,aACoDA,EAAUC,GAAgBD,EAAUC,GAAgBD,EAAUC,GAAiBD,EAAUC,GAC7I,OACIC,QAAO,CAACC,EAAOC,IAgFJN,EAASM,EAAM,IAClBC,SAAW,SAASC,GAChB,IAAIH,EAAMI,SAAS,WAGf,OAAO,EAEX,MAAMC,EAAaT,EAAEK,GAAOK,QACtBC,EAAcX,EAAEK,GAAOO,SACvBC,EAAab,EAAEI,GAAOM,QACtBI,EAAcd,EAAEI,GAAOQ,SAC7B,IAAIG,EAAKC,EAAKC,EAAKC,EAgBnB,OAdIL,GAAYJ,EACZM,EAAKE,GAAMJ,EAAWJ,GAAc,GAEpCM,EAAOF,EAAaJ,EACpBQ,EAAO,GAGPH,GAAaH,EACbK,EAAKE,GAAMJ,EAAYH,GAAe,GAEtCK,EAAOF,EAAcH,EACrBO,EAAO,IAIPC,aACKJ,KAAAA,EACDE,KAAAA,EACAD,KAAAA,EACAE,KAAAA,KAIZE,QAAU,SAASb,GACfT,EAAQuB,KAAKd","file":"../movable.js","sourcesContent":["define([\n    \"skylark-domx-eventer\",\n    \"skylark-domx-plugins-interact/movable\",\n    './domq',\n    './constants'\n], function (eventer,_movable,$, Constants) {\n    'use strict';\n    const ELEMS_WITH_GRABBING_CURSOR = `html, body, .${ Constants.NS }-modal, .${ Constants.NS }-stage, .${ Constants.NS }-button, .${ Constants.NS }-resizable-handle`;\n    return {\n        movable(stage, image) {\n            /*\n            let isDragging = false;\n            let startX = 0;\n            let startY = 0;\n            let left = 0;\n            let top = 0;\n            let widthDiff = 0;\n            let heightDiff = 0;\n            let δ = 0;\n            const dragStart = e => {\n                e = e || window.event;\n                e.preventDefault();\n                const imageWidth = $(image).width();\n                const imageHeight = $(image).height();\n                const stageWidth = $(stage).width();\n                const stageHeight = $(stage).height();\n                startX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.clientX;\n                startY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.clientY;\n                δ = !this.isRotated ? 0 : (imageWidth - imageHeight) / 2;\n                widthDiff = !this.isRotated ? imageWidth - stageWidth : imageHeight - stageWidth;\n                heightDiff = !this.isRotated ? imageHeight - stageHeight : imageWidth - stageHeight;\n                isDragging = widthDiff > 0 || heightDiff > 0 ? true : false;\n                Constants.PUBLIC_VARS['isMoving'] = widthDiff > 0 || heightDiff > 0 ? true : false;\n                left = $(image).position().left - δ;\n                top = $(image).position().top + δ;\n                if (stage.hasClass('is-grab')) {\n                    $(ELEMS_WITH_GRABBING_CURSOR).addClass('is-grabbing');\n                }\n                Constants.$D.on(Constants.TOUCH_MOVE_EVENT + Constants.EVENT_NS, dragMove).on(Constants.TOUCH_END_EVENT + Constants.EVENT_NS, dragEnd);\n            };\n            const dragMove = e => {\n                e = e || window.event;\n                e.preventDefault();\n                if (isDragging) {\n                    const endX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.clientX;\n                    const endY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.clientY;\n                    const relativeX = endX - startX;\n                    const relativeY = endY - startY;\n                    let newLeft = relativeX + left;\n                    let newTop = relativeY + top;\n                    if (heightDiff > 0) {\n                        if (relativeY + top > δ) {\n                            newTop = δ;\n                        } else if (relativeY + top < -heightDiff + δ) {\n                            newTop = -heightDiff + δ;\n                        }\n                    } else {\n                        newTop = top;\n                    }\n                    if (widthDiff > 0) {\n                        if (relativeX + left > -δ) {\n                            newLeft = -δ;\n                        } else if (relativeX + left < -widthDiff - δ) {\n                            newLeft = -widthDiff - δ;\n                        }\n                    } else {\n                        newLeft = left;\n                    }\n                    $(image).css({\n                        left: newLeft + 'px',\n                        top: newTop + 'px'\n                    });\n                    $.extend(this.imageData, {\n                        left: newLeft,\n                        top: newTop\n                    });\n                }\n            };\n            const dragEnd = () => {\n                Constants.$D.off(Constants.TOUCH_MOVE_EVENT + Constants.EVENT_NS, dragMove).off(Constants.TOUCH_END_EVENT + Constants.EVENT_NS, dragEnd);\n                isDragging = false;\n                Constants.PUBLIC_VARS['isMoving'] = false;\n                $(ELEMS_WITH_GRABBING_CURSOR).removeClass('is-grabbing');\n            };\n            $(stage).on(Constants.TOUCH_START_EVENT + Constants.EVENT_NS, dragStart);\n            */\n            \n            \n\n            return _movable(image[0],{\n                starting : function(e) {\n                    if (stage.hasClass('is-grab')) {\n\n                    } else {\n                        return false;\n                    }\n                    const imageWidth = $(image).width();\n                    const imageHeight = $(image).height();\n                    const stageWidth = $(stage).width();\n                    const stageHeight = $(stage).height();\n                    let minX,minY,maxX,maxY;\n\n                    if (stageWidth>=imageWidth) {\n                        minX=maxX=(stageWidth-imageWidth) / 2;\n                    } else {\n                        minX = stageWidth - imageWidth;\n                        maxX = 0;\n                    }\n\n                    if (stageHeight>=imageHeight) {\n                        minY=maxY=(stageHeight-imageHeight) / 2;\n                    } else {\n                        minY = stageHeight - imageHeight;\n                        maxY = 0;\n                    }\n\n                    return {\n                        constraints : {\n                             minX,\n                            maxX,\n                            minY,\n                            maxY\n                        }\n                    };\n                },\n                started : function(e) {\n                    eventer.stop(e);\n                }\n            });\n        }\n    };\n});"]}